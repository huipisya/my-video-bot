import os
import tempfile
import asyncio
import logging
import re
from pathlib import Path
import aiohttp
from aiogram import Bot, Dispatcher, types, F
from aiogram.filters import Command
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, FSInputFile
from aiogram.exceptions import TelegramBadRequest
from dotenv import load_dotenv
import yt_dlp
import instaloader

# === üß∞ –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø ===
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# === üîê –ó–ê–ì–†–£–ó–ö–ê –¢–û–ö–ï–ù–ê ===
load_dotenv()
BOT_TOKEN = os.getenv("BOT_TOKEN")
if not BOT_TOKEN:
    raise ValueError("‚ùå –¢–æ–∫–µ–Ω –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω! –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª .env –∏ –¥–æ–±–∞–≤—å—Ç–µ BOT_TOKEN=–≤–∞—à_—Ç–æ–∫–µ–Ω")

bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()

# === üß† –•–†–ê–ù–ò–õ–ò–©–ï –ù–ê–°–¢–†–û–ï–ö ===
user_settings = {}

# === üé® –°–û–°–¢–û–Ø–ù–ò–Ø FSM ===
class VideoStates(StatesGroup):
    choosing_quality = State()

# === üì∫ –ö–ê–ß–ï–°–¢–í–ê –í–ò–î–ï–û ===
QUALITY_FORMATS = {
    "best": 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
    "1080p": 'bestvideo[ext=mp4][height<=1080]+bestaudio[ext=m4a]/best[height<=1080][ext=mp4]/best',
    "720p": 'bestvideo[ext=mp4][height<=720]+bestaudio[ext=m4a]/best[height<=720][ext=mp4]/best',
    "480p": 'best[height<=480][ext=mp4]/best[ext=mp4]/best',
    "360p": 'best[height<=360][ext=mp4]/best[ext=mp4]/best'
}

# === üõ† –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ===
def get_quality_setting(user_id):
    return user_settings.get(user_id, "best")

def get_ydl_opts(quality="best"):
    return {
        'format': QUALITY_FORMATS.get(quality, QUALITY_FORMATS["best"]),
        'merge_output_format': 'mp4',
        'noplaylist': True,
        'outtmpl': os.path.join(tempfile.gettempdir(), '%(id)s.%(ext)s'),
        'quiet': True,
        'no_warnings': True,
        'http_headers': {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
    }

def is_valid_url(url):
    regex = re.compile(
        r'^(https?://)?(www\.)?'
        r'(youtube\.com|youtu\.be|tiktok\.com|instagram\.com|vm\.tiktok\.com|vt\.tiktok\.com)/',
        re.IGNORECASE
    )
    return re.match(regex, url) is not None

# === üì• –°–ö–ê–ß–ò–í–ê–ù–ò–ï ===
async def download_instagram(url):
    try:
        L = instaloader.Instaloader(
            download_videos=True,
            download_geotags=False,
            download_comments=False,
            save_metadata=False,
            quiet=True
        )
        shortcode = re.search(r'/p/([^/]+)|/reel/([^/]+)', url)
        if not shortcode:
            return None, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–≤–ª–µ—á—å –∫–æ–¥ –ø–æ—Å—Ç–∞ –∏–∑ —Å—Å—ã–ª–∫–∏."

        shortcode = shortcode.group(1) or shortcode.group(2)
        post = instaloader.Post.from_shortcode(L.context, shortcode)

        if not post.is_video:
            return None, "üì∏ –≠—Ç–æ –Ω–µ –≤–∏–¥–µ–æ, –∞ —Ñ–æ—Ç–æ."

        video_url = post.video_url
        temp_path = os.path.join(tempfile.gettempdir(), f"insta_{shortcode}.mp4")

        async with aiohttp.ClientSession() as session:
            async with session.get(video_url) as resp:
                if resp.status == 200:
                    with open(temp_path, 'wb') as f:
                        async for chunk in resp.content.iter_chunked(8192):
                            f.write(chunk)
                    return temp_path, None
                else:
                    return None, f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {resp.status}"
    except Exception as e:
        return None, str(e)

# === üì§ –û–¢–ü–†–ê–í–ö–ê –§–ê–ô–õ–û–í ===
async def send_video_or_link(chat_id, file_path, caption=""):
    file_size = Path(file_path).stat().st_size
    size_mb = file_size / (1024 * 1024)

    if size_mb <= 50:
        try:
            await bot.send_video(chat_id=chat_id, video=FSInputFile(file_path), caption=caption)
            return True
        except TelegramBadRequest as e:
            logger.error(f"Telegram error: {e}")
            return False
    else:
        await bot.send_message(chat_id=chat_id, text=f"üì¶ –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π ({size_mb:.1f} –ú–ë). –†–µ–∞–ª–∏–∑—É–π—Ç–µ –∑–∞–≥—Ä—É–∑–∫—É –Ω–∞ –æ–±–ª–∞–∫–æ.")
        return False

# === üß≠ –ö–õ–ê–í–ò–ê–¢–£–†–´ ===
def main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")]],
        resize_keyboard=True
    )

def settings_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üåü –õ—É—á—à–µ–µ")],
            [KeyboardButton(text="üé¨ 1080p"), KeyboardButton(text="üì∫ 720p")],
            [KeyboardButton(text="‚ö° 480p"), KeyboardButton(text="üì± 360p")],
            [KeyboardButton(text="‚óÄÔ∏è –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )

# === üöÄ –ö–û–ú–ê–ù–î–´ ===
@dp.message(Command("start"))
async def start(message: types.Message, state: FSMContext):
    await state.clear()
    welcome_text = (
        "üé¨ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ VideoBot!</b>\n\n"
        "–Ø –º–æ–≥—É —Å–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ —Å:\n"
        "‚Ä¢ YouTube\n"
        "‚Ä¢ TikTok\n"
        "‚Ä¢ Instagram\n\n"
        " –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏—à–ª–∏ –º–Ω–µ —Å—Å—ã–ª–∫—É –∏ —è –≤—Å—ë —Å–¥–µ–ª–∞—é –∑–∞ —Ç–µ–±—è!"
    )
    await message.answer(welcome_text, reply_markup=main_keyboard(), parse_mode="HTML")

@dp.message(F.text == "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏")
async def settings_menu(message: types.Message, state: FSMContext):
    await state.set_state(VideoStates.choosing_quality)
    current = get_quality_setting(message.from_user.id)
    await message.answer(
        f"‚öôÔ∏è –¢–µ–∫—É—â–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ: <b>{current.upper()}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤–æ–µ:",
        reply_markup=settings_keyboard(),
        parse_mode="HTML"
    )

@dp.message(VideoStates.choosing_quality, F.text.in_(["üåü –õ—É—á—à–µ–µ", "üé¨ 1080p", "üì∫ 720p", "‚ö° 480p", "üì± 360p"]))
async def set_quality(message: types.Message, state: FSMContext):
    quality_map = {
        "üåü –õ—É—á—à–µ–µ": "best",
        "üé¨ 1080p": "1080p",
        "üì∫ 720p": "720p",
        "‚ö° 480p": "480p",
        "üì± 360p": "360p"
    }
    user_settings[message.from_user.id] = quality_map[message.text]
    await message.answer(f"‚úÖ –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∫–∞—á–µ—Å—Ç–≤–æ: <b>{message.text}</b>", reply_markup=main_keyboard(), parse_mode="HTML")
    await state.clear()

@dp.message(VideoStates.choosing_quality, F.text == "‚óÄÔ∏è –ù–∞–∑–∞–¥")
async def back_to_main(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_keyboard())

# === üì• –û–ë–†–ê–ë–û–¢–ö–ê –°–°–´–õ–û–ö ===
@dp.message(F.text)
async def handle_link(message: types.Message):
    url = message.text.strip()
    if not is_valid_url(url):
        await message.answer("‚ö†Ô∏è –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—Å—ã–ª–∫—É –Ω–∞ YouTube, TikTok –∏–ª–∏ Instagram.")
        return

    status_msg = await message.answer("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é —Å—Å—ã–ª–∫—É...")
    user_quality = get_quality_setting(message.from_user.id)
    temp_file = None

    try:
        # Instagram
        if 'instagram.com' in url:
            temp_file, error = await download_instagram(url)
            if error:
                await status_msg.edit_text(error)
                return

        # YouTube / TikTok
        else:
            ydl_opts = get_ydl_opts(user_quality)
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                temp_file = ydl.prepare_filename(info)

        if not temp_file or not os.path.exists(temp_file):
            await status_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–∏–¥–µ–æ.")
            return

        await status_msg.edit_text("üì§ –û—Ç–ø—Ä–∞–≤–ª—è—é –≤–∏–¥–µ–æ...")
        await send_video_or_link(message.chat.id, temp_file, caption="üé• –í–æ—Ç –≤–∞—à–µ –≤–∏–¥–µ–æ!")

    except yt_dlp.DownloadError as e:
        await status_msg.edit_text(f"‚ùå –û—à–∏–±–∫–∞ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è: {str(e)}")
    except Exception as e:
        await status_msg.edit_text(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
    finally:
        if temp_file and os.path.exists(temp_file):
            try:
                os.remove(temp_file)
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {e}")

# === üèÅ –ó–ê–ü–£–°–ö ===
async def main():
    logger.info("üöÄ –ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º")